<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        
        <title>Max Subsequence Sum Problem / 最大子序列和问题</title>
        
        <link rel="alternate" type="application/rss+xml" title="Pengyu Chen">
        <link rel="shortcut icon" href="/favicon.ico">
        <!-- syntax highlighting css -->
        <link rel="stylesheet" type="text/css" href="/css/syntax.css">
        <!-- homepage css -->
        <link rel="stylesheet" type="text/css" href="/css/hgtip/aal.css">
        <link rel="stylesheet" type="text/css" href="/css/hgtip/calluna.css">
        <link rel="stylesheet" type="text/css" href="/css/hgtip/style.css">
    </head>
    <body>
        <div id="main-wrap">
            <div id="header">
                <h1><a href="/" title="Pengyu Chen">Pengyu Chen</a></h1>
                <br />
            </div>
            <p id="navigation">
                <a href="/pages/archives.html">Archives</a> &mdash;
                <a href="/pages/projects.html">Projects</a> &mdash;
                <a href="/pages/people.html">People</a> &mdash;
                <a href="/pages/favorite.html">Favorite</a> &mdash;
                <a href="/pages/about.html">About</a>
            </p>
            <div id="content">
                
<h2>Max Subsequence Sum Problem / 最大子序列和问题</h2>

<p id="tip-info">November 17, 2015 @ 09:33 PM</p>
<p><center><strong>------English (英文)------</strong></center></p>

<p>Given (possibly negative) integers a1, a2, ..., an, find the maximum value of ∑ ak. The maximum subsequence sum is defined to be 0 if all the integers are negative. </p>

<p>For example, given the sequence -2, 11, -4, 13, -5, -2, the maximum subsequence sum is 20: a2 through a4. </p>

<p>The most obvious approach is an algorithm with O(N^3).</p>

<p><1> Algorithm 1 -- <code>O(N^3)</code></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">int MaxSubsequenceSum(const int A[], int N)
{
    int ThisSum, MaxSum, i, j, k;

    MaxSum = 0;
    for(i = 0; i &lt; N; i++)
        for(j = i; j &lt; N; j++)
        {
            ThisSum = 0;
            for(k = i; k &lt;= j; k++ )
                ThisSum += A[k];

            if(ThisSum &gt; MaxSum)
                MaxSum = ThisSum;
        }
    return MaxSum;
}
</code></pre></div>
<p>A better approach may perform as O(N^2).</p>

<p><2> Algorithm 2 -- <code>O(N^2)</code></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">int MaxSubsequenceSum(const int A[], int N)
{
    int ThisSum, MaxSum, i, j;

    MaxSum = 0;
    for(i = 0; i &lt; N; i++)
    {
        ThisSum = 0;
        for(j = 0; j &lt; N; j++)
        {
            ThisSum += A[j];
            if(ThisSum &gt; MaxSum)
                MaxSum = ThisSum;
        }
    }

    return MaxSum;
}
</code></pre></div>
<p>We also may apply divide-and-conquer approach for this problem.</p>

<p><3> Algorithm 3 -- <code>O(NlogN)</code></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">int MaxSubSum(const int A[], int Left, int Right)
{
    int MaxLeftSum, MaxRightSum;
    int MaxLeftBorderSum, MaxRightBorderSum;
    int LeftBorderSum, RightBorderSum;
    int Center, i;

    if(Left == Right)
    {
        if(A[Left] &gt; 0)
            return A[Left];
        else 
            return 0;
    }

    Center = (Left + Right) / 2;
    MaxLeftSum = MaxSubSum(A, Left, Center);
    MaxRightSum = MaxSubSum(A, Center + 1, Right);

    MaxLeftBorderSum = 0; LeftBorderSum = 0;
    for(i = Center; i &gt;= Left; i--)
    {
        LeftBorderSum += A[i];
        if(LeftBorderSum &gt; MaxLeftBorderSum)
            MaxLeftBorderSum = LeftBorderSum;
    }

    MaxRightBorderSum = 0; RightBorderSum = 0;
    for(i = Center; i &lt;= Right; i++)
    {
        RightBorderSum += A[i];
        if(RightBorderSum &gt; MaxRightBorderSum)
            MaxRightBorderSum = RightBorderSum;
    }

    return Max3(MaxLeftSum, MaxRightSum, MaxLeftBorderSum + MaxRightBorderSum);

}

int MaxSubsequenceSum(const int A[], int N)
{
    return MaxSubSum(A, 0, N - 1);
}
</code></pre></div>
<p>However, there has an optimal solution can achieve O(N).</p>

<p><4> Algorithm 4 -- <code>O(N)</code></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">int MaxSubsequenceSum(const int A[], int N)
{
    int ThisSum, MaxSum, i;

    ThisSum = 0; MaxSum = 0;
    for(i = 0; i &lt; N; i++)
    {
        ThisSum += A[i];
        if(ThisSum &gt; MaxSum)
            MaxSum = ThisSum;
        else if(ThisSum &lt; 0)
            ThisSum = 0;
    }

    return MaxSum;
}
</code></pre></div>
<div id="tip-comments">
    <h2>Related Posts</h2>
    <ul>
        
        <li><a href="/2015/10/27/cordova-android.html">Cordova-Android Plugin Example / Cordova-Android 插件详解</a> &raquo; October 27, 2015</li>
        
        <li><a href="/2015/09/01/codility.html">A Good Site for Coding Test / Codility, 练习编码的好平台</a> &raquo; September  1, 2015</li>
        
        <li><a href="/2015/07/31/get-cell-value-swift.html">Get Value from Cells of TableView / TableView点击获取当前Cell内容</a> &raquo; July 31, 2015</li>
        
    </ul>
</div>

            </div>
            <div id="footer">
                Follow me: <a href="https://github.com/ShongSu">Github</a> / <a href="https://ca.linkedin.com/pub/pengyu-chen/86/538/852">Linkedin</a> 
            </div>
        </div>
    </body>
</html>
